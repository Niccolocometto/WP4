#ifndef KERNEL_EVENTREADERFACTORY_H
#define KERNEL_EVENTREADERFACTORY_H

#include <iostream>
#include <errno.h>
#include "../EventBuffer.h"
#include "../../c/raven_api.h"
#include "Factory.h"


/**
 * A factory responsible for instantiating EventReaders.
 *
 * @author Humberto Carvalho (1120409@isep.ipp.pt)
 * @date
 */
template<class T>
class EventReaderFactory : public Factory {
public: //todo buffer_list
    /**
   * Instantiates an EventReader.
   *
   * Instantiates an event reader that pops Events from an kernel side EventBuffer.
   *
   * The buffer id will be generated by ftok, which generates an ID from a file and an id.
   *
   * @param reader The reader to instantiate.
   * @param file the file to generate the id from.
   * @param id the id to combine with the id generated from the file. Only the low-order 8-bits of id are significant.
   *
   *  @return returns 0 on success. On error -1 is returned and errno is set appropriately.
   *
   *  errno error list:
   *  - ENOENT : The buffer id at event_buffer does not exist.
   *  - EINVAL : The buffer index length does not match the length of the template type T.
   *  Please consult your ftok documentation to see which errors might be produced.
   *
   */
    static int buildEventReader(EventReader<T> &reader, const char *file, int const id);

    /**
    * Instantiates an EventReader.
    *
    * Instantiates an event reader that pops Events from an kernel side EventBuffer.
    *
    * @param reader The reader to instantiate.
    * @param id The EventBuffers id.
    *
    *  @return returns 0 on success. On error -1 is returned and errno is set appropriately.
    *
    *  errno error list:
    *  - ENOENT : The buffer id at event_buffer does not exist.
    *  - EINVAL : The buffer index length does not match the length of the template type T.
    */
    static int buildEventReader(EventReader<T> &reader, const key_t id);

    /**
     * Instantiates an EventReader from an EventBuffer.
     */
    static void buildEventReader(EventReader<T> &reader, EventBuffer<T> eventBuffer);

    /**
     * Instantiates a SynchronizedEventReader.
     *
     * Instantiates a synchronized event reader that pops Events from an kernel side EventBuffer.
     *
     * The buffer id will be generated by ftok, which generates an ID from a file and an id.
     *
     * @param reader The reader to instantiate.
     * @param synch the synchronization variable.
     * @param file the file to generate the id from.
     * @param id the id to combine with the id generated from the file. Only the low-order 8-bits of id are significant.
     *
     *  @return returns 0 on success. On error -1 is returned and errno is set appropriately.
     *
     *  errno error list:
     *  - ENOENT : The buffer id at event_buffer does not exist.
     *  - EINVAL : The buffer index length does not match the length of the template type T.
     *  Please consult your ftok documentation to see which errors might be produced.
     *
     */
    static int buildSynchronizedEventReader(SynchronizedEventReader<T> &reader, struct timespec *synch, const char *file,
                                            int const id);

    /**
    * Instantiates a SynchronizedEventReader.
    *
    * Instantiates a  synchronized event reader that pops Events from an kernel side EventBuffer.
    *
    * @param reader The reader to instantiate.
    * @param synch the synchronization variable to use with this synchronized event reader.
    * @param id The EventBuffers id.
    *
    *  @return returns 0 on success. On error -1 is returned and errno is set appropriately.
    *
    *  errno error list:
    *  - ENOENT : The buffer id at event_buffer does not exist.
    *  - EINVAL : The buffer index length does not match the length of the template type T.
    */
    static int buildSynchronizedEventReader(SynchronizedEventReader<T> &reader, struct timespec *synch, const key_t id);

    /**
    * Instantiates an SynchronizedEventReader from an EventBuffer.
    *
    * @param reader the reader to instantiate.
    * @param synch the synchronization variable.
    * @param eventBuffer the EventBuffer to to opo events from.
    */
    static void buildSynchronizedEventReader(SynchronizedEventReader<T> &reader, struct timespec *synch, EventBuffer<T> eventBuffer);
};


template<class T>
int EventReaderFactory<T>::buildEventReader(EventReader<T> &reader, const char *file, int const id) {
    key_t buf_id;
    if ((buf_id = getBufferId(file, id)) == (key_t) -1)
        return -1;

    struct event_buffer_info info;
    if(raven_buffer_info(id,&info)) return -1;

    if(info.index_size!=sizeof(T)){
        errno=EINVAL;
        return -1;
    }

    reader.configure(buf_id);
    return 0;
}

template<class T>
int EventReaderFactory<T>::buildEventReader(EventReader<T> &reader, const key_t id) {
    struct event_buffer_info info;
    if(raven_buffer_info(id,&info)) return -1;

    if(info.index_size!=sizeof(T)){
        errno=EINVAL;
        return -1;
    }

    reader.configure(id);
}

template<class T>
int EventReaderFactory<T>::buildSynchronizedEventReader(SynchronizedEventReader<T> &reader, struct timespec *synch, const char *file,
                                                        int const id) {
    key_t buf_id;
    if ((buf_id = getBufferId(file, id)) == (key_t) -1)
        return -1;

    struct event_buffer_info info;
    if(raven_buffer_info(id,&info)) return -1;

    if(info.index_size!=sizeof(T)){
        errno=EINVAL;
        return -1;
    }

    reader.configure(buf_id,synch);
}

template<class T>
int EventReaderFactory<T>::buildSynchronizedEventReader(SynchronizedEventReader<T> &reader, struct timespec *synch,
                                                        const key_t id) {

    struct event_buffer_info info;
    if(raven_buffer_info(id,&info)) return -1;

    if(info.index_size!=sizeof(T)){
        errno=EINVAL;
        return -1;
    }
    reader.configure(id,synch);
}


template<class T>
void EventReaderFactory<T>::buildEventReader(EventReader<T> &reader, EventBuffer<T> eventBuffer) {
    reader.configure(eventBuffer.getID());
}

template<class T>
void EventReaderFactory<T>::buildSynchronizedEventReader(SynchronizedEventReader<T> &reader, struct timespec *synch,
                                                         EventBuffer<T> eventBuffer) {
    reader.configure(eventBuffer.getID(),synch);
}
#endif //KERNEL_EVENTREADERFACTORY_H
